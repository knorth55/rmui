#!/usr/bin/env roseus

(require :prx-utils "package://rmuieus/euslisp/prx-utils.l")

;; parameters

(defvar *device* (make-cube 120 120 120))
(defvar *device-frame-id* "rmui_link")
(defvar *prx-threshold* 500)
(defvar *prx-position-threshold* 0.1)
(defvar *motion-symbol-length* 20)
(defvar *world-frame-id* "world")

;; functions

(setq *object-contact-states* (list :released :released :bottom-contact))
(setq *motion-symbol-queue* (list nil nil))


(defun get-motion-symbols (contact-positions)
  (let* ((larm-motion-symbols
           (get-motion-symbol :larm contact-positions))
         (rarm-motion-symbols
           (get-motion-symbol :rarm contact-positions)))
    (list larm-motion-symbols rarm-motion-symbols)))


(defun get-motion-symbol (arm contact-positions)
  (let ((contact-surfaces (mapcar #'car contact-positions))
        (larm-contact-state (car *object-contact-states*))
        (rarm-contact-state (cadr *object-contact-states*))
        (floor-contact-state (caddr *object-contact-states*)))
    ;; TODO (knorth55): add switch rotate conditions
    (if (equal arm :larm)
      (cond
        ((and (or (equal rarm-contact-state :released)
                  (equal rarm-contact-state :right-contact))
              (null (equal larm-contact-state :left-contact))
              (equal floor-contact-state :bottom-contact)
              (find :left contact-surfaces)
              (find :bottom contact-surfaces))
         :left-push)
        ((and (or (equal rarm-contact-state :released)
                  (equal rarm-contact-state :back-contact))
              (null (equal larm-contact-state :front-contact))
              (equal floor-contact-state :bottom-contact)
              (find :front contact-surfaces)
              (find :bottom contact-surfaces))
         :front-push)
        ((and (or (equal rarm-contact-state :released)
                  (equal rarm-contact-state :front-contact))
              (null (equal larm-contact-state :back-contact))
              (equal floor-contact-state :bottom-contact)
              (find :back contact-surfaces)
              (find :bottom contact-surfaces))
         :back-push)
        ((or (and (equal larm-contact-state :left-contact)
             ;      (equal rarm-contact-state :right-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :left contact-surfaces))
                  (find :bottom contact-surfaces))
             (and (equal larm-contact-state :front-contact)
             ;      (equal rarm-contact-state :front-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :front contact-surfaces))
                  (find :bottom contact-surfaces))
             (and (equal larm-contact-state :back-contact)
             ;      (equal rarm-contact-state :back-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :back contact-surfaces))
                  (find :bottom contact-surfaces)))
         :push-release)
        ((and (or (and (equal larm-contact-state :front-contact)
                       (equal rarm-contact-state :back-contact))
                  (and (equal larm-contact-state :back-contact)
                       (equal rarm-contact-state :front-contact))
                  (and (equal larm-contact-state :left-contact)
                       (equal rarm-contact-state :right-contact)))
              (equal floor-contact-state :bottom-contact)
              (null (find :bottom contact-surfaces)))
         :push-hold-up)
        ((and (or (and (equal larm-contact-state :front-contact)
                       (equal rarm-contact-state :back-contact))
                  (and (equal larm-contact-state :back-contact)
                       (equal rarm-contact-state :front-contact))
                  (and (equal larm-contact-state :left-contact)
                       (equal rarm-contact-state :right-contact)))
              (null (equal floor-contact-state :bottom-contact))
              (find :bottom contact-surfaces))
         :push-hold-down)
        ((null contact-positions) nil)
        (t nil))
      (cond
        ((and (or (equal larm-contact-state :released)
                  (equal larm-contact-state :left-contact))
              (null (equal rarm-contact-state :right-contact))
              (equal floor-contact-state :bottom-contact)
              (find :right contact-surfaces)
              (find :bottom contact-surfaces))
         :right-push)
        ((and (or (equal larm-contact-state :released)
                  (equal larm-contact-state :back-contact))
              (null (equal rarm-contact-state :front-contact))
              (equal floor-contact-state :bottom-contact)
              (find :front contact-surfaces)
              (find :bottom contact-surfaces))
         :front-push)
        ((and (or (equal larm-contact-state :released)
                  (equal larm-contact-state :front-contact))
              (null (equal rarm-contact-state :back-contact))
              (equal floor-contact-state :bottom-contact)
              (find :back contact-surfaces)
              (find :bottom contact-surfaces))
         :back-push)
        ((or (and (equal rarm-contact-state :right-contact)
                  ; (equal larm-contact-state :left-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :right contact-surfaces))
                  (find :bottom contact-surfaces))
             (and (equal rarm-contact-state :front-contact)
                  ; (equal larm-contact-state :back-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :front contact-surfaces))
                  (find :bottom contact-surfaces))
             (and (equal rarm-contact-state :back-contact)
                  ; (equal larm-contact-state :front-contact)
                  (equal floor-contact-state :bottom-contact)
                  (null (find :back contact-surfaces))
                  (find :bottom contact-surfaces)))
         :push-release)
        ((and (or (and (equal larm-contact-state :front-contact)
                       (equal rarm-contact-state :back-contact))
                  (and (equal larm-contact-state :back-contact)
                       (equal rarm-contact-state :front-contact))
                  (and (equal larm-contact-state :left-contact)
                       (equal rarm-contact-state :right-contact)))
              (equal floor-contact-state :bottom-contact)
              (null (find :bottom contact-surfaces)))
         :push-hold-up)
        ((and (or (and (equal larm-contact-state :front-contact)
                       (equal rarm-contact-state :back-contact))
                  (and (equal larm-contact-state :back-contact)
                       (equal rarm-contact-state :front-contact))
                  (and (equal larm-contact-state :left-contact)
                       (equal rarm-contact-state :right-contact)))
              (null (equal floor-contact-state :bottom-contact))
              (find :bottom contact-surfaces))
         :push-hold-down)
        ((null contact-positions) nil)
        (t nil)))))


(defun execute-motion-symbols (motion-symbols &key (move-robot t) (use-torso 0.001))
  (let ((larm-motion-symbol-queue (car *motion-symbol-queue*))
        (rarm-motion-symbol-queue (cadr *motion-symbol-queue*))
        (larm-motion-symbol (car motion-symbols))
        (rarm-motion-symbol (cadr motion-symbols))
        (larm-contact-state (car *object-contact-states*))
        (rarm-contact-state (cadr *object-contact-states*))
        (floor-contact-state (caddr *object-contact-states*))
        larm-execute-p rarm-execute-p)
    (setq larm-motion-symbol-queue
          (append
            (if (>= (length larm-motion-symbol-queue) *motion-symbol-length*)
              (cdr larm-motion-symbol-queue) larm-motion-symbol-queue)
            (list larm-motion-symbol)))
    (setq rarm-motion-symbol-queue
          (append
            (if (>= (length rarm-motion-symbol-queue) *motion-symbol-length*)
              (cdr rarm-motion-symbol-queue) rarm-motion-symbol-queue)
            (list rarm-motion-symbol)))
    (setq larm-execute-p
          (and (>= (length larm-motion-symbol-queue) *motion-symbol-length*)
               (every #'(lambda (x) (equal x larm-motion-symbol)) larm-motion-symbol-queue)))
    (setq rarm-execute-p
          (and (>= (length rarm-motion-symbol-queue) *motion-symbol-length*)
               (every #'(lambda (x) (equal x rarm-motion-symbol)) rarm-motion-symbol-queue)))
    (setq larm-motion-symbol (if larm-execute-p larm-motion-symbol))
    (setq rarm-motion-symbol (if rarm-execute-p rarm-motion-symbol))
    (setq *motion-symbol-queue* (list larm-motion-symbol-queue rarm-motion-symbol-queue))

    (if (or larm-motion-symbol rarm-motion-symbol)
      (progn
        (if (equal larm-motion-symbol rarm-motion-symbol)
          (cond
            ((and (equal larm-motion-symbol :push-hold-up)
                  (equal rarm-motion-symbol :push-hold-up)
                  (and (equal floor-contact-state :bottom-contact)
                       (or (and (equal larm-contact-state :left-contact)
                                (equal rarm-contact-state :right-contact))
                           (and (equal larm-contact-state :front-contact)
                                (equal rarm-contact-state :back-contact))
                           (and (equal larm-contact-state :back-contact)
                                (equal rarm-contact-state :front-contact)))))
             (assoc-cube :arms)
             (hold-lift-up-motion :move-robot move-robot :use-torso use-torso)
             (dissoc-cube :arms)
             (return-from execute-motion-symbols (list larm-motion-symbol rarm-motion-symbol)))
            ((and (equal larm-motion-symbol :push-hold-down)
                  (equal rarm-motion-symbol :push-hold-down)
                  (and (equal floor-contact-state :released)
                       (or (and (equal larm-contact-state :left-contact)
                                (equal rarm-contact-state :right-contact))
                           (and (equal larm-contact-state :front-contact)
                                (equal rarm-contact-state :back-contact))
                           (and (equal larm-contact-state :back-contact)
                                (equal rarm-contact-state :front-contact)))))
             (assoc-cube :arms)
             (hold-lift-down-motion :move-robot move-robot :use-torso use-torso)
             (dissoc-cube :arms)
             (return-from execute-motion-symbols (list larm-motion-symbol rarm-motion-symbol)))
            (t nil)))
        (if larm-motion-symbol
          (cond
            ((and (equal larm-motion-symbol :left-push)
                  (and (equal larm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :larm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :y)
                          :push-positions (list :center)
                          :push-directions (list :left)
                          :approach-directions (list :back)
                          :approach-arm :larm)
             (return-from execute-motion-symbols (list larm-motion-symbol nil)))
            ((and (equal larm-motion-symbol :front-push)
                  (and (equal larm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :larm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :x)
                          :push-positions (list :center)
                          :push-directions (list :front)
                          :approach-directions (list :left)
                          :approach-arm :larm)
             (return-from execute-motion-symbols (list larm-motion-symbol nil)))
            ((and (equal larm-motion-symbol :back-push)
                  (and (equal larm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :larm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :x)
                          :push-positions (list :center)
                          :push-directions (list :back)
                          :approach-directions (list :left)
                          :approach-arm :larm)
             (return-from execute-motion-symbols (list larm-motion-symbol nil)))
            ((and (equal larm-motion-symbol :push-release)
                  (and (equal floor-contact-state :bottom-contact)
                       (or (equal larm-contact-state :left-contact)
                           (equal larm-contact-state :front-contact)
                           (equal larm-contact-state :back-contact))))
             (push-release-motion :larm :move-robot move-robot :use-torso use-torso)
             (return-from execute-motion-symbols (list larm-motion-symbol nil)))
            (t nil)))
        (if rarm-motion-symbol
          (cond
            ((and (equal rarm-motion-symbol :right-push)
                  (and (equal rarm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :rarm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :y)
                          :push-positions (list :center)
                          :push-directions (list :right)
                          :approach-directions (list :back)
                          :approach-arm :rarm)
             (return-from execute-motion-symbols (list nil rarm-motion-symbol)))
            ((and (equal rarm-motion-symbol :front-push)
                  (and (equal rarm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :rarm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :x)
                          :push-positions (list :center)
                          :push-directions (list :front)
                          :approach-directions (list :right)
                          :approach-arm :rarm)
             (return-from execute-motion-symbols (list nil rarm-motion-symbol)))
            ((and (equal rarm-motion-symbol :back-push)
                  (and (equal rarm-contact-state :released)
                       (equal floor-contact-state :bottom-contact)))
             (push-motion :rarm :move-robot move-robot :use-torso use-torso
                          :push-axes (list :x)
                          :push-positions (list :center)
                          :push-directions (list :back)
                          :approach-directions (list :right)
                          :approach-arm :rarm)
             (return-from execute-motion-symbols (list nil rarm-motion-symbol)))
            ((and (equal rarm-motion-symbol :push-release)
                  (and (equal floor-contact-state :bottom-contact)
                       (or (equal rarm-contact-state :right-contact)
                           (equal rarm-contact-state :front-contact)
                           (equal rarm-contact-state :back-contact))))
             (push-release-motion :rarm :move-robot move-robot :use-torso use-torso)
             (return-from execute-motion-symbols (list nil rarm-motion-symbol)))
            (t nil)))))))


(defun update-object-contact-state (motion-symbols)
  (unless motion-symbols (return-from update-object-contact-state nil))
  (let ((larm-motion-symbol (car motion-symbols))
        (rarm-motion-symbol (cadr motion-symbols))
        (larm-contact-state (car *object-contact-states*))
        (rarm-contact-state (cadr *object-contact-states*))
        (floor-contact-state (caddr *object-contact-states*)))
    (setq larm-contact-state
        (cond
          ((and (equal larm-motion-symbol :left-push)
                (equal larm-contact-state :released))
           :left-contact)
          ((and (equal larm-motion-symbol :front-push)
                (equal larm-contact-state :released))
           :front-contact)
          ((and (equal larm-motion-symbol :back-push)
                (equal larm-contact-state :released))
           :back-contact)
          ((and (equal larm-motion-symbol :push-release)
                (or (equal larm-contact-state :left-contact)
                    (equal larm-contact-state :front-contact)
                    (equal larm-contact-state :back-contact)))
           :released)
          (t larm-contact-state)))
    (setq rarm-contact-state
        (cond
          ((and (equal rarm-motion-symbol :right-push)
                (equal rarm-contact-state :released))
           :right-contact)
          ((and (equal rarm-motion-symbol :front-push)
                (equal rarm-contact-state :released))
           :front-contact)
          ((and (equal rarm-motion-symbol :back-push)
                (equal rarm-contact-state :released))
           :back-contact)
          ((and (equal rarm-motion-symbol :push-release)
                (or (equal rarm-contact-state :right-contact)
                    (equal rarm-contact-state :front-contact)
                    (equal rarm-contact-state :back-contact)))
           :released)
          (t rarm-contact-state)))
    (setq floor-contact-state
          (cond
            ((and (equal larm-motion-symbol :push-hold-up)
                  (equal rarm-motion-symbol :push-hold-up))
             :released)
            ((and (equal larm-motion-symbol :push-hold-down)
                  (equal rarm-motion-symbol :push-hold-down))
             :bottom-contact)
            (t floor-contact-state)))
    (setq *object-contact-states*
          (list larm-contact-state rarm-contact-state floor-contact-state))))


(provide :rmui-planners "rmui-planners.l")
